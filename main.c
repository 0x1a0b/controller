/* Copyright (C) 2011-2014 by Jacob Alexander
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

// ----- Includes -----

// Compiler Includes
#include <Lib/MainLib.h>

// Project Includes
#include <macro.h>
#include <scan_loop.h>
#include <output_com.h>

#include <cli.h>
#include <led.h>
#include <print.h>



// ----- Defines -----

// Verified Keypress Defines
#define USB_TRANSFER_DIVIDER 10 // 1024 == 1 Send of keypresses per second, 1 == 1 Send of keypresses per ~1 millisecond



// ----- Macros -----
#if defined(_at90usb162_) || defined(_atmega32u4_) || defined(_at90usb646_) || defined(_at90usb1286_)
#define CPU_PRESCALE(n)	(CLKPR = 0x80, CLKPR = (n))
#endif



// ----- Function Declarations -----

void cliFunc_distRead    ( char* args );
void cliFunc_free        ( char* args );
void cliFunc_gaugeHelp   ( char* args );
void cliFunc_single      ( char* args );
void cliFunc_start       ( char* args );
void cliFunc_zeroForce   ( char* args );
void cliFunc_zeroPosition( char* args );



// ----- Variables -----

// Timer Interrupt for flagging a send of the sampled key detection data to the USB host
uint16_t sendKeypressCounter = 0;

// Flag generated by the timer interrupt
volatile uint8_t sendKeypresses = 0;



// ----- Functions -----

// Initial Pin Setup, make sure they are sane
inline void pinSetup(void)
{

// AVR
#if defined(_at90usb162_) || defined(_atmega32u4_) || defined(_at90usb646_) || defined(_at90usb1286_)

	// For each pin, 0=input, 1=output
#if defined(__AVR_AT90USB1286__)
	DDRA = 0x00;
#endif
	DDRB = 0x00;
	DDRC = 0x00;
	DDRD = 0x00;
	DDRE = 0x00;
	DDRF = 0x00;


	// Setting pins to either high or pull-up resistor
#if defined(__AVR_AT90USB1286__)
	PORTA = 0x00;
#endif
	PORTB = 0x00;
	PORTC = 0x00;
	PORTD = 0x00;
	PORTE = 0x00;
	PORTF = 0x00;

// ARM
#elif defined(_mk20dx128_)
	// TODO - Should be cleared, but not that necessary due to the pin layout
#endif
}


inline void usbTimerSetup(void)
{
// AVR
#if defined(_at90usb162_) || defined(_atmega32u4_) || defined(_at90usb646_) || defined(_at90usb1286_)

	// Setup with 16 MHz clock
	CPU_PRESCALE( 0 );

	// Setup ISR Timer for flagging a kepress send to USB
	// Set to 256 * 1024 (8 bit timer with Clock/1024 prescalar) timer
	TCCR0A = 0x00;
	TCCR0B = 0x03;
	TIMSK0 = (1 << TOIE0);

// ARM
#elif defined(_mk20dx128_)
	// 48 MHz clock by default

	// System Clock Gating Register Disable
	SIM_SCGC6 |= SIM_SCGC6_PIT;

	// Enable Timers
	PIT_MCR = 0x00;

	// Setup ISR Timer for flagging a kepress send to USB
	// 1 ms / (1 / 48 MHz) - 1 = 47999 cycles -> 0xBB7F
	PIT_LDVAL0 = 0x0000BB7F;
	PIT_TCTRL0 = 0x3; // Enable Timer 0 interrupts, and Enable Timer 0

	// Insert the required vector for Timer 0
	NVIC_ENABLE_IRQ( IRQ_PIT_CH0 );
#endif
}


int main(void)
{
	// Configuring Pins
	pinSetup();
	init_errorLED();

	// Setup Output Module
	output_setup();

	// Enable CLI
	init_cli();

	// Setup ISR Timer for flagging a kepress send to USB
	usbTimerSetup();

	// Main Detection Loop
	uint8_t ledTimer = F_CPU / 1000000; // Enable LED for a short time
	while ( 1 )
	{
		// Setup the scanning module
		scan_setup();

		while ( 1 )
		{
			// Acquire Key Indices
			// Loop continuously until scan_loop returns 0
			cli();
			while ( scan_loop() );
			sei();

			// Run Macros over Key Indices and convert to USB Keys
			process_macros();

			// Send keypresses over USB if the ISR has signalled that it's time
			if ( !sendKeypresses )
				continue;

			// Send USB Data
			usb_send();

			// Clear sendKeypresses Flag
			sendKeypresses = 0;

			// Indicate Error, if valid
			errorLED( ledTimer );

			if ( ledTimer > 0 )
				ledTimer--;
		}

		// Loop should never get here (indicate error)
		ledTimer = 255;

		// HID Debug Error message
		erro_print("Detection loop error, this is very bad...bug report!");
	}
}


// ----- Interrupts -----

// USB Keyboard Data Send Counter Interrupt
#if defined(_at90usb162_) || defined(_atmega32u4_) || defined(_at90usb646_) || defined(_at90usb1286_) // AVR
ISR( TIMER0_OVF_vect )
#elif defined(_mk20dx128_) // ARM
void pit0_isr(void)
#endif
{
	sendKeypressCounter++;
	if ( sendKeypressCounter > USB_TRANSFER_DIVIDER ) {
		sendKeypressCounter = 0;
		sendKeypresses = 1;
	}

#if defined(_mk20dx128_) // ARM
	// Clear the interrupt flag
	PIT_TFLG0 = 1;
#endif
}


// ----- CLI Command Functions -----

void cliFunc_distRead( char* args )
{
	// Prepare to print output
	print( NL );
	info_msg("Distance: ");

	// Data
	uint32_t distInput = 0;

	// Setup distance read parameters for iGaging Distance Scale
	//       freq = 9kHz
	// duty_cycle = 20%
	// high_delay = (1/freq) *       (duty_cycle/100)
	//  low_delay = (1/freq) * ((100-duty_cycle)/100)
	uint8_t  bits       = 21; // 21 clock pulses, for 21 bits
	//uint32_t high_delay = 22; // Clock high time per pulse
	//uint32_t  low_delay = 89; // Clock low  time per pulse
	uint32_t high_delay = 40; // Clock high time per pulse
	uint32_t  low_delay = 60; // Clock low  time per pulse

	// Make sure clock is low initially
	GPIOC_PCOR |= (1<<2); // Set Clock low
/*
while(1)
{
*/
	// Scan each of the bits
	for ( uint8_t bit = bits; bit > 0; bit-- )
	{
		// Begin clock pulse
		GPIOC_PSOR |= (1<<2); // Set Clock high

		// Delay for duty cycle
		delayMicroseconds( high_delay );

		// End clock pulse
		GPIOC_PCOR |= (1<<2); // Set Clock low

		// Read Data Bit
		//distInput |= GPIOD_PDIR & (1<<6) ? (1 << (bit - 1)) : 0;
		//if ( GPIOD_PDIR )
		if ( GPIOD_PDIR & (1<<6) )
		{
			print("1");
		}
		else
		{
			print("0");
		}

		// Delay for duty cycle
		delayMicroseconds( low_delay );
	}
	print("  ");

	// Output result
	printInt32( distInput );

	// Convert to mm
	// As per http://www.shumatech.com/web/21bit_protocol?page=0,1
	// 21 bits is 2560 CPI (counts per inch) (C/inch)
	// 1 inch is 25.4 mm
	// 2560 / 25.4 = 100.7874016... CPMM (C/mm)
	// Or
	// 1 count is 1/2560 = 0.000390625... inches
	// 1 count is (1/2560) * 25.4 = 0.0000153789370078740 mm = 0.0153789370078740 um = 15.3789370078740 nm
	// Since there are 21 bits (2 097 152 positions) converting to um is possible by multiplying by 1000
	//    which is 2 097 152 000, and within 32 bits (4 294 967 295).
	// However, um is still not convenient, so 64 bits (18 446 744 073 709 551 615) is a more accurate alternative.
	// For each nm there are 2 097 152 000 000 positions.
	// And for shits:
	//    pm is 2 097 152                 :          0.000 015 378 937 007 874 0 mm : 32 bit
	//    pm is 2 097 152 000             :          0.015 378 937 007 874 0     um : 32 bit (ideal acc. for 32 bit)
	//    pm is 2 097 152 000 000         :         15.378 937 007 874 0         nm : 64 bit
	//    pm is 2 097 152 000 000 000     :     15 378.937 007 874 0             pm : 64 bit
	//    fm is 2 097 152 000 000 000 000 : 15 378 937.007 874 0                 fm : 64 bit (ideal acc. for 64 bit)
	//uint64_t distNM = distInput * 15;
	//uint64_t distPM = distInput * 15378;
	uint64_t distFM = distInput * 15378937;

	// Calculate um and mm
	//uint32_t distNM = distInput * 15; // XXX
	//uint32_t distUM = distNM / 1000;
	//uint32_t distMM = distNM / 1000000;
	uint32_t distNM = distFM * 1000000;
	uint32_t distUM = distNM / 1000;
	uint32_t distMM = distUM / 1000;

	print("  ");
	printInt32( distMM );
	print(" mm  ");
	printInt32( distUM );
	print(" um  ");
	printInt32( distNM );
	print(" nm");

/*
//Wait
print(NL);
delay( 7 );
distInput = 0;
}
*/
}


void cliFunc_free( char* args )
{
}


void cliFunc_gaugeHelp( char* args )
{
}


void cliFunc_single( char* args )
{
}


void cliFunc_start( char* args )
{
}


void cliFunc_zeroForce( char* args )
{
}


void cliFunc_zeroPosition( char* args )
{
}

